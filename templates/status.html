<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2 Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      
      body {
        background: linear-gradient(135deg, #0a0a0a 0%, #111 100%);
        font-family: 'Audiowide', sans-serif;
        color: #C7CBCB;
        min-height: 100vh;
        padding: 20px;
        overflow-x: hidden;
        position: relative;
      }
      
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
          radial-gradient(circle at 20% 30%, rgba(117, 224, 117, 0.05) 0%, transparent 40%),
          radial-gradient(circle at 80% 70%, rgba(117, 224, 117, 0.05) 0%, transparent 40%),
          linear-gradient(135deg, rgba(0, 20, 0, 0.2) 0%, rgba(0, 0, 0, 0.8) 100%);
        z-index: -1;
      }
      
      .grid-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(rgba(117, 224, 117, 0.05) 1px, transparent 1px),
          linear-gradient(90deg, rgba(117, 224, 117, 0.05) 1px, transparent 1px);
        background-size: 40px 40px;
        z-index: -1;
        pointer-events: none;
      }
      
      .container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }
      
      header {
        text-align: center;
        padding: 20px 0;
        margin-bottom: 20px;
        border-bottom: 1px solid rgba(117, 224, 117, 0.3);
      }
      
      h1 {
        font-size: clamp(2.2rem, 5vw, 3.5rem);
        margin: 0;
        letter-spacing: 2px;
        text-shadow: 0 0 10px rgba(117, 224, 117, 0.7);
      }
      
      h1 .dash {
        color: #75E075;
      }
      
      .status-bar {
        background: rgba(20, 20, 20, 0.8);
        border: 1px solid rgba(117, 224, 117, 0.3);
        border-radius: 8px;
        padding: 12px 20px;
        margin: 20px 0;
        display: flex;
        align-items: center;
        width: 100%;
        box-shadow: 0 0 15px rgba(117, 224, 117, 0.2);
      }
      
      .status-indicator {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 15px;
        background: #75E075;
        box-shadow: 0 0 10px #75E075;
        animation: pulse 2s infinite;
      }
      
      .status-text {
        font-size: clamp(1rem, 3vw, 1.4rem);
        color: #75E075;
        flex-grow: 1;
        text-align: left;
      }
      
      @keyframes pulse {
        0% { opacity: 0.7; }
        50% { opacity: 1; }
        100% { opacity: 0.7; }
      }
      
      .dashboard-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 30px;
        width: 100%;
        margin-top: 20px;
      }
      
      .metrics-panel {
        background: rgba(10, 15, 10, 0.7);
        border: 1px solid rgba(117, 224, 117, 0.3);
        border-radius: 10px;
        padding: 20px;
        flex: 1;
        min-width: 300px;
        max-width: 500px;
        box-shadow: 0 0 20px rgba(117, 224, 117, 0.2);
      }
      
      .metrics-panel h2 {
        font-size: clamp(1.4rem, 3vw, 1.8rem);
        margin-bottom: 15px;
        color: #75E075;
        text-align: center;
        border-bottom: 1px solid rgba(117, 224, 117, 0.3);
        padding-bottom: 10px;
      }
      
      .metric-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      
      .metric-item {
        background: rgba(15, 20, 15, 0.6);
        border: 1px solid rgba(117, 224, 117, 0.2);
        border-radius: 6px;
        padding: 12px;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      .metric-label {
        font-size: clamp(0.8rem, 2vw, 0.9rem);
        color: #9CA3AF;
        margin-bottom: 5px;
      }
      
      .metric-value {
        font-size: clamp(1.1rem, 3vw, 1.4rem);
        color: #75E075;
        font-weight: 500;
      }
      
      .status-passed {
        color: #75E075 !important;
      }
      
      .status-failed {
        color: #ff4d4d !important;
      }
      
      .graph-panel {
        background: rgba(10, 15, 10, 0.7);
        border: 1px solid rgba(117, 224, 117, 0.3);
        border-radius: 10px;
        padding: 20px;
        flex: 1;
        min-width: 300px;
        max-width: 600px;
        box-shadow: 0 0 20px rgba(117, 224, 117, 0.2);
      }
      
      .graph-panel h2 {
        font-size: clamp(1.4rem, 3vw, 1.8rem);
        margin-bottom: 15px;
        color: #75E075;
        text-align: center;
        border-bottom: 1px solid rgba(117, 224, 117, 0.3);
        padding-bottom: 10px;
      }
      
      .graph-container {
        position: relative;
        height: 250px;
        width: 100%;
        overflow: hidden;
      }
      
      canvas {
        width: 100%;
        height: 100%;
      }
      
      .uptime-info {
        margin-top: 20px;
        text-align: center;
        font-size: clamp(0.9rem, 2vw, 1.1rem);
        color: #9CA3AF;
      }
      
      .uptime-value {
        color: #75E075;
        font-weight: 500;
      }
      
      footer {
        margin-top: 30px;
        text-align: center;
        color: #6B7280;
        font-size: clamp(0.8rem, 2vw, 0.9rem);
        padding: 20px;
        width: 100%;
        border-top: 1px solid rgba(117, 224, 117, 0.2);
      }
      
      .glowing-text {
        text-shadow: 0 0 8px rgba(117, 224, 117, 0.8);
      }
      
      @media (max-width: 768px) {
        .dashboard-container {
          flex-direction: column;
          align-items: center;
        }
        
        .metrics-panel, .graph-panel {
          width: 100%;
          max-width: 100%;
        }
        
        .metric-grid {
          grid-template-columns: 1fr;
        }
      }
      
      /* Mobile-specific styles */
      @media (max-width: 480px) {
        body {
          padding: 10px;
        }
        
        .metric-item {
          padding: 10px;
          min-height: 70px;
        }
        
        .graph-container {
          height: 200px;
        }
        
        .status-bar {
          padding: 10px 15px;
        }
      }
      
      /* Scrollable container for smaller heights */
      @media (max-height: 700px) {
        .container {
          min-height: 700px;
        }
      }
    </style>
</head>
<body>
  <div class="grid-overlay"></div>
  
  <div class="container">
    <header>
      <h1>E2 <span class="dash">Dashboard</span></h1>
    </header>
    
    <div class="status-bar">
      <div class="status-indicator"></div>
      <div class="status-text">ONLINE - Connected to Telegram via HTTPX</div>
    </div>
    
    <div class="dashboard-container">
      <div class="metrics-panel">
        <h2>Performance Metrics</h2>
        <div class="metric-grid">
          <div class="metric-item">
            <div class="metric-label">Samples</div>
            <div class="metric-value" id="samples">2020</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Ping</div>
            <div class="metric-value" id="ping">2 ms</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Last</div>
            <div class="metric-value" id="last">2 ms</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Average</div>
            <div class="metric-value" id="avg">3.2 ms</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Failures</div>
            <div class="metric-value" id="failure">12</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Max Response</div>
            <div class="metric-value" id="max-resp">42 ms</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Min Response</div>
            <div class="metric-value" id="min-resp">1 ms</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Online Status</div>
            <div class="metric-value status-passed" id="online-status">200 OK</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Scraping Check</div>
            <div class="metric-value status-passed" id="scraping-check">Passed</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Uptime</div>
            <div class="metric-value" id="uptime">00:00:00</div>
          </div>
          <div class="metric-item">
            <div class="metric-label">Success Rate</div>
            <div class="metric-value" id="success-rate">100%</div>
          </div>
        </div>
      </div>
      
      <div class="graph-panel">
        <h2>Uptime & Performance</h2>
        <div class="graph-container">
          <canvas id="uptimeGraph"></canvas>
        </div>
        <div class="uptime-info">
          Instance started: <span class="uptime-value" id="start-time">2025-08-09 12:47:32 UTC</span>
        </div>
      </div>
    </div>
    
    <footer>
      <p>E2 Monitoring System â€¢ Last updated: <span id="timestamp">2025-08-09 12:47:32 UTC</span></p>
    </footer>
  </div>

  <script>
    // Initialize canvas
    const canvas = document.getElementById('uptimeGraph');
    const ctx = canvas.getContext('2d');
    
    // Set initial start time
    const startTime = new Date();
    document.getElementById('start-time').textContent = startTime.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
    
    // Set canvas dimensions
    function setCanvasSize() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
      drawGraph();
    }
    
    // Generate random data for the graph
    function generateData() {
      const data = [];
      const now = Date.now();
      
      // Generate 30 data points (last 30 minutes)
      for (let i = 0; i < 30; i++) {
        const time = new Date(now - (30 - i) * 60000);
        // Simulate response times between 1-10ms with occasional spikes
        let value = 1 + Math.random() * 4;
        if (Math.random() > 0.9) value += 10 + Math.random() * 30;
        data.push({ time, value });
      }
      
      return data;
    }
    
    // Draw the graph
    function drawGraph() {
      const data = generateData();
      const padding = 40;
      const width = canvas.width - padding * 2;
      const height = canvas.height - padding * 2;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(117, 224, 117, 0.2)';
      ctx.lineWidth = 1;
      
      // Vertical grid lines
      for (let i = 0; i <= 5; i++) {
        const x = padding + (width / 5) * i;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, padding + height);
        ctx.stroke();
      }
      
      // Horizontal grid lines
      for (let i = 0; i <= 5; i++) {
        const y = padding + (height / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(padding + width, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = 'rgba(117, 224, 117, 0.5)';
      ctx.lineWidth = 2;
      
      // X-axis
      ctx.beginPath();
      ctx.moveTo(padding, padding + height);
      ctx.lineTo(padding + width, padding + height);
      ctx.stroke();
      
      // Y-axis
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, padding + height);
      ctx.stroke();
      
      // Draw labels
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '12px Audiowide';
      ctx.textAlign = 'center';
      
      // X-axis labels (time)
      for (let i = 0; i <= 5; i++) {
        const minutesAgo = 30 - (i * 6);
        const label = minutesAgo === 0 ? 'Now' : `${minutesAgo}m ago`;
        const x = padding + (width / 5) * i;
        ctx.fillText(label, x, padding + height + 20);
      }
      
      // Y-axis labels (response time)
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const value = (5 - i) * 10;
        const y = padding + (height / 5) * i;
        ctx.fillText(`${value}ms`, padding - 10, y + 4);
      }
      
      // Draw data line
      ctx.beginPath();
      ctx.strokeStyle = '#75E075';
      ctx.lineWidth = 3;
      ctx.lineJoin = 'round';
      
      // Find max value for scaling
      const maxValue = Math.max(...data.map(d => d.value), 1);
      
      data.forEach((point, i) => {
        const x = padding + (width / (data.length - 1)) * i;
        const y = padding + height - (point.value / maxValue) * height;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
      
      // Draw data points
      data.forEach((point, i) => {
        const x = padding + (width / (data.length - 1)) * i;
        const y = padding + height - (point.value / maxValue) * height;
        
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#75E075';
        ctx.fill();
      });
    }
    
    // Calculate uptime dynamically
    function calculateUptime(startTime) {
      const now = new Date();
      const diff = now - startTime;
      
      const seconds = Math.floor(diff / 1000);
      const hours = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;
      
      return {
        formatted: `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`,
        totalSeconds: seconds
      };
    }
    
    // Calculate success rate dynamically
    function calculateSuccessRate(samples, failures) {
      if (samples === 0) return 100;
      const successRate = ((samples - failures) / samples) * 100;
      return successRate.toFixed(1);
    }
    
    // Update metrics with dynamic values
    function updateMetrics(startTime) {
      // Update timestamp
      const now = new Date();
      const timestamp = now.toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
      document.getElementById('timestamp').textContent = timestamp;
      
      // Update uptime
      const uptime = calculateUptime(startTime);
      document.getElementById('uptime').textContent = uptime.formatted;
      
      // Simulate metric changes
      let samples = parseInt(document.getElementById('samples').textContent);
      samples += Math.floor(Math.random() * 3);
      document.getElementById('samples').textContent = samples;
      
      // Update failures
      let failures = parseInt(document.getElementById('failure').textContent);
      if (Math.random() > 0.97) failures++;
      document.getElementById('failure').textContent = failures;
      
      // Update success rate
      const successRate = calculateSuccessRate(samples, failures);
      document.getElementById('success-rate').textContent = `${successRate}%`;
      
      // Randomly update ping and last values
      const ping = Math.max(1, Math.floor(Math.random() * 10));
      document.getElementById('ping').textContent = ping + ' ms';
      document.getElementById('last').textContent = ping + ' ms';
      
      // Update average
      const avg = parseFloat(document.getElementById('avg').textContent);
      const newAvg = ((avg * (samples - 1)) + ping) / samples;
      document.getElementById('avg').textContent = newAvg.toFixed(1) + ' ms';
      
      // Update max/min responses
      const maxResp = parseInt(document.getElementById('max-resp').textContent);
      const minResp = parseInt(document.getElementById('min-resp').textContent);
      
      if (ping > maxResp) {
        document.getElementById('max-resp').textContent = ping + ' ms';
      }
      
      if (ping < minResp || minResp === 0) {
        document.getElementById('min-resp').textContent = ping + ' ms';
      }
      
      // Occasionally change scraping status (3% chance)
      if (Math.random() < 0.03) {
        const status = Math.random() > 0.3 ? 'Passed' : 'Failed';
        const colorClass = status === 'Passed' ? 'status-passed' : 'status-failed';
        
        const element = document.getElementById('scraping-check');
        element.textContent = status;
        element.className = 'metric-value ' + colorClass;
      }
    }
    
    // Initialize the dashboard
    function initDashboard() {
      const startTime = new Date();
      
      setCanvasSize();
      updateMetrics(startTime);
      
      // Redraw graph when window is resized
      window.addEventListener('resize', setCanvasSize);
      
      // Update metrics every second
      setInterval(() => updateMetrics(startTime), 1000);
      
      // Redraw graph every 30 seconds
      setInterval(drawGraph, 30000);
    }
    
    // Start the dashboard when page loads
    window.addEventListener('load', initDashboard);
  </script>
</body>
</html>